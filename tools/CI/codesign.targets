<!--
****************************************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.

Authenticode and StrongName signing targets.
****************************************************************************************************
-->

<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">

  <UsingTask AssemblyFile="$(MSBuildThisFileDirectory)Microsoft.Web.MsBuildTasks2.dll" TaskName="Microsoft.Web.MsBuildTasks.SubmitCodeSignJob" />
  <UsingTask AssemblyFile="$(MSBuildThisFileDirectory)Microsoft.Web.MsBuildTasks2.dll" TaskName="Microsoft.Web.MsBuildTasks.WaitForCodeSignJobs" />

  <!--
  ==================================================================================================
  CodeSign item/prop definition with default parameters - https://codesign.gtm.microsoft.com/ 
  Used during the build to identify and place files to be signed in the corresponding bin.
  ================================================================================================== -->
  <PropertyGroup>
    <CodeSignEnabled Condition="!$(Configuration.ToLowerInvariant().Contains('release'))">false</CodeSignEnabled>
    <CodeSignEnabled Condition="'$(MSBuildProjectExtension)' == '.nuproj'">false</CodeSignEnabled>
    <CodeSignEnabled Condition="'$(MSBuildProjectExtension)' == '.wixproj' AND '$(OutputType)' == 'Library'">false</CodeSignEnabled>
    <CodeSignEnabled Condition="'$(CodeSignEnabled)' == ''">false</CodeSignEnabled>
  </PropertyGroup>

  <!-- Handling for different MSBuildVersions -->
  <PropertyGroup>
    <CodeTaskFactoryAssemblyFile Condition=" '$(CodeTaskFactoryAssemblyFile)' == '' And '$(MSBuildToolsVersion)' == '12.0' ">$(MSBuildToolsPath)\Microsoft.Build.Tasks.v12.0.dll</CodeTaskFactoryAssemblyFile>
    <CodeTaskFactoryAssemblyFile Condition=" '$(CodeTaskFactoryAssemblyFile)' == '' ">$(MSBuildToolsPath)\Microsoft.Build.Tasks.v4.0.dll</CodeTaskFactoryAssemblyFile>
  </PropertyGroup>

  <PropertyGroup>
    <!-- Location where signed binries are placed.-->
    <CodeSignOutputPath Condition="'$(CodeSignOutputPath)' == ''">$(OutputPath)Signed\</CodeSignOutputPath>
    <CodeSignOutputPath Condition="!HasTrailingSlash('$(CodeSignOutputPath)')">$(CodeSignOutputPath)\</CodeSignOutputPath>
    <!-- Used for computing path for placing signed assemblies (if not provided) relative to the CodeSignOutputPath -->
    <CodeSignRepoBinRoot Condition="'$(CodeSignRepoBinRoot)' == ''">$(OutputPath)</CodeSignRepoBinRoot>
    <CodeSignRepoBinRoot Condition="!HasTrailingSlash('$(CodeSignRepoBinRoot)')">$(CodeSignRepoBinRoot)\</CodeSignRepoBinRoot>
    <!-- Used for computing path for placing signed assemblies (when provided) relative to the CodeSignOutputPath -->
    <CodeSignRelativeOutDir Condition="'$(CodeSignRelativeOutDir)' != '' AND !HasTrailingSlash('$(CodeSignRelativeOutDir)')">$(CodeSignRelativeOutDir)\</CodeSignRelativeOutDir>
    <!-- CodeSign intermediate output path-->
    <CodeSignIntermediateOutputPath Condition="'$(CodeSignIntermediateOutputPath)' == ''">$(IntermediateOutputPath)CodeSign\</CodeSignIntermediateOutputPath>
    <CodeSignIntermediateOutputPath Condition="!HasTrailingSlash('$(CodeSignIntermediateOutputPath)')">$(CodeSignIntermediateOutputPath)\</CodeSignIntermediateOutputPath>
    <!-- Path for placing scripts generated by the SubmitCodeSignJob task, these scripts copy the signed files back from the signing server.-->
    <CodeSignScriptsPath Condition="'$(CodeSignScriptsPath)' == ''">$(CodeSignOutputPath)Scripts\</CodeSignScriptsPath>
    <CodeSignScriptsPath Condition="!HasTrailingSlash('$(CodeSignScriptsPath)')">$(CodeSignScriptsPath)\</CodeSignScriptsPath>
    <!-- The base name for the script that copies signed files into CodeSignPath -->
    <CodeSignCopyScriptName Condition="'$(CodeSignCopyScriptName)' == ''">CopySignedFiles</CodeSignCopyScriptName>
    <!-- The path to the folder where manifest files are generated into. -->
    <CodeSignManifestPath Condition="'$(CodeSignManifestPath)' == ''">$(CodeSignIntermediateOutputPath)Manifest\</CodeSignManifestPath>
    <CodeSignManifestPath Condition="!HasTrailingSlash('$(CodeSignManifestPath)')">$(CodeSignManifestPath)\</CodeSignManifestPath>
    <!-- The path to place files with a unique name to optimize job submitions (for instance satellite assemblies) -->
    <CodeSignBinFlatPath Condition="'$(CodeSignBinFlatPath)' == ''">$(CodeSignIntermediateOutputPath)Flat\</CodeSignBinFlatPath>
    <CodeSignBinFlatPath Condition="!HasTrailingSlash('$(CodeSignBinFlatPath)')">$(CodeSignBinFlatPath)\</CodeSignBinFlatPath>
    <!-- The extension of the generated manifest file -->
    <CodeSignManifestExtension Condition="'$(CodeSignManifestExtension)' == ''">.codesign</CodeSignManifestExtension>
    <!-- Determines whether unsigned files should be deleted after files are signed and before signed files are copied back. -->
    <CodeSignDeleteUnsignedFiles Condition="'$(CodeSignDeleteUnsignedFiles)' == ''">false</CodeSignDeleteUnsignedFiles>
    <!-- Test mode for CodeSignSubmitJob task, some parameters are tested (connnectivity) but the job is not sent.-->
    <CodeSignTest Condition="'$(CodeSignTest)' == ''">false</CodeSignTest>
    <!-- When in test mode connection to the sign server is not done.-->
    <CodeSignTestOffline Condition="'$(CodeSignTestOffline)' == ''">false</CodeSignTestOffline>
    <!-- When in test mode manifests and temporary files are deleted, test signed files are moved to their destination -->
    <CodeSignTestUpdateFiles Condition="'$(CodeSignTestUpdateFiles)' == ''">true</CodeSignTestUpdateFiles>
    <!-- Default authenticode certificate key-->
    <CodeSignAuthCodeCert Condition="'$(CodeSignAuthCodeCert)' == ''">10006</CodeSignAuthCodeCert>
  </PropertyGroup>

  <PropertyGroup>
    <!--Force a rebuild if this file is changed -->
    <MSBuildAllProjects>$(MSBuildAllProjects);$(MSBuildThisFileFullPath)</MSBuildAllProjects>
  </PropertyGroup>

  <ItemDefinitionGroup Label="CodeSign Defaults">
    <CodeSign>
      <AuthCodeCert>$(CodeSignAuthCodeCert)</AuthCodeCert>
      <StrongNameCert>$(CodeSignSnCert)</StrongNameCert>
      <DisplayName>$(CodeSignDisplayName)</DisplayName>
      <DisplayUrl>$(CodeSignDisplayUrl)</DisplayUrl>
      <Description Condition="'$(CodeSignDescription)' != ''">$(CodeSignDescription)</Description>
      <Description Condition="'$(CodeSignDescription)' == ''">$(CodeSignDisplayName) Signing Job.</Description>
      <SignedOutDir>$(CodeSignOutputPath)</SignedOutDir>
      <RelativeOutDir>$(CodeSignRelativeOutDir)</RelativeOutDir>
      <ManifestPath />
      <PathHashCode />
      <InProject>false</InProject>
    </CodeSign>
  </ItemDefinitionGroup>

  <!-- CodeSign item group should not be conditioned based on CodeSignEnable to allow for cleaning any previous items. -->
  <ItemGroup Condition="'@(CodeSign)' == ''">
    <!-- CultureGroup is defined or Wix projects that are localizable -->
    <CodeSign Include="$(TargetPath)" Condition="'@(CultureGroup)' == ''" />
    <CodeSign Include="$(OutputPath)%(CultureGroup.OutputFolder)\$(OutputName).msi" Condition="'@(CultureGroup)' != ''" />
  </ItemGroup>

  <!--
 ==================================================================================================
 CodeSign target: Core target for submitting code sign jobs.
 NOTE: Since CodeSign is a global target that needs to be run multiple times during a build, it 
 needs to be invoked with different properties everytime so MSBuild does not skip the target after
 first invoked, for instance: DummyPropForceSign=SomeUniqueValue.
 If CodeSign is called on a specific project it will sign the project-specified CodeSign items only.
 ==================================================================================================-->
  <PropertyGroup>
    <CodeSignDependsOn Condition="'$(CodeSignEnabled)' == 'true'">EnsureCodeSign;ValidateCodeSign;GetCodeSignJob;SubmitSignJobs</CodeSignDependsOn>
  </PropertyGroup>
  <Target Name="CodeSign" DependsOnTargets="$(CodeSignDependsOn)" />

  <!--
 ==================================================================================================
 ValidateCodeSign: Performs some CodeSign validations for the project being built.
 ==================================================================================================-->
  <Target Name="ValidateCodeSign" Condition="'$(CodeSignEnabled)' == 'true'">
    <PropertyGroup>
      <CodeSignEnabled Condition="'@(CodeSign)' == ''">false</CodeSignEnabled>
    </PropertyGroup>
    <ItemGroup Condition="'$(CodeSignEnabled)' == 'true'">
      <ErrorCondition Condition="'$(CodeSignOutputPath)' != '' AND !HasTrailingSlash('$(CodeSignOutputPath)')" Include="CodeSignOutputPath must end with a trailing slash: $(CodeSignOutputPath)" />
      <ErrorCondition Condition="'$(CodeSignOutputPath)' != '' AND !HasTrailingSlash('$(CodeSignOutputPath)')" Include="CodeSignOutputPath must end with a trailing slash: $(CodeSignOutputPath)" />
      <ErrorCondition Condition="'$(CodeSignRepoBinRoot)' != '' AND !HasTrailingSlash('$(CodeSignRepoBinRoot)')" Include="CodeSignRepoBinRoot must end with a trailing slash: $(CodeSignRepoBinRoot)" />
      <ErrorCondition Condition="'$(CodeSignRelativeOutDir)' != '' AND !HasTrailingSlash('$(CodeSignRelativeOutDir)')" Include="CodeSignRelativeOutDir must end with a trailing slash: $(CodeSignRelativeOutDir)" />
      <ErrorCondition Condition="'$(CodeSignIntermediateOutputPath)' != '' AND !HasTrailingSlash('$(CodeSignIntermediateOutputPath)')" Include="CodeSignIntermediateOutputPath must end with a trailing slash: $(CodeSignIntermediateOutputPath)" />
      <ErrorCondition Condition="'$(CodeSignScriptsPath)' != '' AND !HasTrailingSlash('$(CodeSignScriptsPath)')" Include="CodeSignCodeSignScriptsPathManifestPath must end with a trailing slash: $(CodeSignScriptsPath)" />
      <ErrorCondition Condition="'$(CodeSignManifestPath)' != '' AND !HasTrailingSlash('$(CodeSignManifestPath)')" Include="CodeSignManifestPath must end with a trailing slash: $(CodeSignManifestPath)" />
      <ErrorCondition Condition="'$(CodeSignBinFlatPath)' != '' AND !HasTrailingSlash('$(CodeSignBinFlatPath)')" Include="CodeSignBinFlatPath must end with a trailing slash: $(CodeSignBinFlatPath)" />
      <ErrorCondition Condition="'%(CodeSign.SignedOutDir)' != '' AND !HasTrailingSlash('%(CodeSign.SignedOutDir)')" Include="SignedOutDir must end with a trailing slash. CodeSign item: %(Identity)" />
      <ErrorCondition Condition="'%(CodeSign.RelativeOutDir)' != '' AND !HasTrailingSlash('%(CodeSign.RelativeOutDir)')" Include="RelativeOutDir must end with a trailing slash. CodeSign item: %(Identity)" />
    </ItemGroup>
    <Warning Condition="'@(CodeSign)' == ''" Text="CodeSign collection is empty, CodeSign will be disabled." />
    <Error Condition="'@(ErrorCondition)' != ''" Text="@(ErrorCondition -> '%(Identity)%0A')" />
  </Target>

  <!--
 ==================================================================================================
 GenerateCodeSignManifest: Generates a manifest with CodeSign info for the specified file.
 ==================================================================================================-->
  <PropertyGroup Condition="'$(CodeSignEnabled)' == 'true'">
    <BuildDependsOn>$(BuildDependsOn);GenerateCodeSignManifest</BuildDependsOn>
  </PropertyGroup>
  <Target Name="GenerateCodeSignManifest" DependsOnTargets="ValidateCodeSign" Condition="'@(CodeSign)' != '' AND '$(CodeSignEnabled)' == 'true'">
    <UpdateCodeSignMetadata CodeSign="@(CodeSign)" ManifestDirectory="$(CodeSignManifestPath)" ManifestExtension="$(CodeSignManifestExtension)">
      <Output TaskParameter="CodeSignUpdated" ItemName="CodeSign" />
    </UpdateCodeSignMetadata>
    <!-- Ensure outdated CodeSign items are discarded. -->
    <ItemGroup>
      <CodeSign Remove="@(CodeSign)" Condition="'%(PathHashCode)' == ''" />
    </ItemGroup>
    <MakeDir Directories="$(CodeSignManifestPath)" />
    <WriteLinesToFile File="%(CodeSign.ManifestPath)" Overwrite="true" Condition="!Exists('%(ManifestPath)') AND Exists('%(FullPath)')"
                      Lines="ItemSpec=%(FullPath);
                             AuthCodeCert=%(AuthCodeCert);
                             StrongNameCert=%(StrongNameCert);
                             Description=%(Description);
                             DisplayName=%(DisplayName);
                             DisplayUrl=%(DisplayUrl);
                             SignedOutDir=%(SignedOutDir);
                             RelativeOutDir=%(RelativeOutDir)" />
    <Message Text="CodeSign manifest: %(CodeSign.ManifestPath)" Condition="Exists('%(CodeSign.ManifestPath)')"/>
  </Target>

  <!--
 ==================================================================================================
 GetCodeSignFromManifest target: Populates the CodeSign collection from manifest files.
 It is possible that CodeSign is invoked directly for a project w/o invoking Build, for instance 
 when signing a dll that was produced with CodeSign disabled; in this case no manifest is needed 
 because the CodeSign ItemGroup is available.
 ==================================================================================================-->
  <Target Name="GetCodeSignFromManifest" Condition="'@(CodeSign)' == ''">
    <ItemGroup>
      <CodeSignManifest Include="$(CodeSignManifestPath)**\*$(CodeSignManifestExtension)" />
    </ItemGroup>
    <Message Condition="'@(CodeSignManifest)' == ''" Text="No CodeSign manifest found. Manifest path:$(CodeSignManifestPath)" />
    <GetCodeSignFromManifest ManifestFiles="@(CodeSignManifest)" OutputRoot="$(CodeSignRepoBinRoot)">
      <Output ItemName="CodeSign" TaskParameter="CodeSign" />
    </GetCodeSignFromManifest>
  </Target>

  <!--
 ==================================================================================================
 EnsureCodeSign target: Ensures the CodeSign ItemGroup's metadata is fully populated.
 ==================================================================================================-->
  <Target Name="EnsureCodeSign" DependsOnTargets="GetCodeSignFromManifest">
    <!-- If CodeSign was invoked directly for a project, the CodeSign items need to be updated. -->
    <UpdateCodeSignMetadata Condition="'%(PathHashCode)' == ''"
       CodeSign="@(CodeSign)" ManifestDirectory="$(CodeSignManifestPath)" ManifestExtension="$(CodeSignManifestExtension)">
      <Output TaskParameter="CodeSignUpdated" ItemName="CodeSign" />
    </UpdateCodeSignMetadata>
    <!-- Ensure outdated CodeSign items are discarded. -->
    <ItemGroup>
      <CodeSign Remove="@(CodeSign)" Condition="'%(PathHashCode)' == ''" />
    </ItemGroup>
  </Target>

  <!--
 ==================================================================================================
 GetCodeSignJob target: Populates the CodeSignJob ItemGroup in batches, this group represents the 
 input to the SubmitCodeSignJob task.
 Intermediate CodeSign file names are created by flattening the original file paths appeneded with 
 a hash computed from the file's full path to uniquely identify it in the flat directory.  This is to 
 optimize the number of jobs to be submitted by batching files with different orignal names but same
 sign properties (satellite assemblies for instance).
 Once files are signed they are copied back to the unflattened destination paths. This is done by 
 the cmd scripts generated by the SubmiCodeSignJob task.
 ==================================================================================================-->
  <Target Name="GetCodeSignJob" DependsOnTargets="EnsureCodeSign">
    <ItemGroup>
      <CodeSignJobTemp Include="@(CodeSign)" Condition="Exists('%(FullPath)')">
        <IntermediateFileName>%(FileName)_%(PathHashCode)%(Extension)</IntermediateFileName>
        <SignedFilePath>%(SignedOutDir)%(RelativeOutDir)%(FileName)%(Extension)</SignedFilePath>
        <ManifestPath>%(ManifestPath)</ManifestPath>
        <CodeSignCopyScript>$(CodeSignScriptsPath)$(CodeSignCopyScriptName)_%(AuthCodeCert)_%(StrongNameCert).cmd</CodeSignCopyScript>
        <CodeSignCopyScriptTargetPath>$(CodeSignOutputPath)</CodeSignCopyScriptTargetPath>
        <CodeSignCertificates>%(AuthCodeCert);%(StrongNameCert)</CodeSignCertificates>
        <CodeSignDescription>%(Description)</CodeSignDescription>
        <CodeSignDisplayName>%(DisplayName)</CodeSignDisplayName>
        <CodeSignDisplayUrl>%(DisplayUrl)</CodeSignDisplayUrl>
      </CodeSignJobTemp>
    </ItemGroup>
    <SortItems ItemGroup="@(CodeSignJobTemp)">
      <Output TaskParameter="SortedItemGroup" ItemName="CodeSignJob"/>
    </SortItems>
  </Target>

  <!--
 ==================================================================================================
 ListCodeSignJobs target: List files to be signed grouped by sign jobs.
 ==================================================================================================-->
  <Target Name="ListCodeSignJobs" DependsOnTargets="GetCodeSignJob">
    <Message Importance="high" Text="Approvers: $(CodeSignApprovers)" />
    <Message Importance="high" Text="CodeSign jobs:0" Condition="'@(CodeSignJob)' == ''" />
    <Message Importance="high" Condition="'@(CodeSignJob)' != ''" Text="%0ACodeSign job (@(CodeSignJob->Count()) files):
        CodeSignCopyScript=%(CodeSignCopyScript)
        CodeSignCopyScriptTargetPath=%(CodeSignCopyScriptTargetPath)
        CodeSignCertificates=%(CodeSignCertificates)
        CodeSignDescription=%(CodeSignDescription)
        CodeSignDisplayName=%(CodeSignDisplayName)
        CodeSignDisplayUrl=%(CodeSignDisplayUrl)%0A%0A@(CodeSignJob->'%(FullPath) [Hash:%(PathHashCode)] --> %(SignedFilePath)', '%0A')" />
  </Target>

  <!--
 ==================================================================================================
 SubmitSignJobs: Submits the final jobs in batches based on the CodeSignJob ItemGroup metadata.
 ==================================================================================================-->
  <Target Name="SubmitSignJobs" Condition="'$(CodeSignEnabled)' == 'true' AND '@(CodeSignJob)' != ''">
    <Warning Text="CodeSignTest is enabled!" Condition="'$(CodeSignTest)' == 'true'" />
    <ItemGroup>
      <Approvers Include="$(CodeSignApprovers)" Exclude="$(USERNAME)" />
    </ItemGroup>
    <PropertyGroup>
      <CodeSignApprovers>@(Approvers)</CodeSignApprovers>
    </PropertyGroup>

    <Message Importance="high" Text="%0ASubmitCodeSignJob (%(CodeSignCertificates))
    CopyScript=%(CodeSignCopyScript)
    CopyScriptRemoveTargetFolder=false
    CopyScriptTargetPath=%(CodeSignCopyScriptTargetPath)
    Approvers=$(CodeSignApprovers)
    Certificates=%(CodeSignCertificates)
    Description=%(CodeSignDescription)
    DisplayName=%(CodeSignDisplayName)
    DisplayUrl=%(CodeSignDisplayUrl)
    GenerateCopyScript=true
    Test=$(CodeSignTest)
    Files=%0A@(CodeSignJob -> '%(FullPath) -> %(IntermediateFileName)', '%0A')" />

    <RemoveDir Directories="$(CodeSignBinFlatPath)" ContinueOnError="true" />
    <MakeDir Directories="@(CodeSignJob -> '%(CodeSignCopyScriptTargetPath)')" />
    <MakeDir Directories="$([System.IO.Path]::GetDirectoryName('%(CodeSignJob.CodeSignCopyScript)'))" />

    <!-- Generate intermediate files to be submitted to the signing server -->
    <Copy SourceFiles="%(CodeSignJob.FullPath)" DestinationFiles="$(CodeSignBinFlatPath)%(CodeSignJob.IntermediateFileName)" />

    <SubmitCodeSignJob
        CopyScript="%(CodeSignCopyScript)"
        CopyScriptRemoveTargetFolder="false"
        CopyScriptTargetPath="%(CodeSignCopyScriptTargetPath)"
        Approvers="$(CodeSignApprovers)"
        Certificates="%(CodeSignCertificates)"
        Description="%(CodeSignDescription)"
        DisplayName="%(CodeSignDisplayName)"
        DisplayUrl="%(CodeSignDisplayUrl)"
        Files="@(CodeSignJob -> '$(CodeSignBinFlatPath)%(IntermediateFileName)')"
        GenerateCopyScript="true"
        Poll="false"
        SSL="true"
        Test="$(CodeSignTest)" Condition="'$(CodeSignTestOffline)' != 'true'">
      <Output TaskParameter="JobNumber" ItemName="CodeSignJobNumber" />
    </SubmitCodeSignJob>

    <WaitForCodeSignJobs JobNumbers="@(CodeSignJobNumber)" Test="$(CodeSignTest)" Condition="'$(CodeSignTestOffline)' != 'true'"/>

    <ItemGroup>
      <CodeSignDelete Include="@(CodeSignJob -> '%(ManifestPath)')" />
      <CodeSignDelete Include="@(CodeSignJob -> '$(CodeSignBinFlatPath)%(IntermediateFileName)')" />
      <CodeSignDelete Include="@(CodeSignJob -> '%(FullPath)')" Condition="'$(CodeSignDeleteUnsignedFiles)' == 'true'"/>
    </ItemGroup>

    <PropertyGroup>
      <CodeSignTestUpdateFiles Condition="'$(CodeSignTestOffline)' == 'true'">false</CodeSignTestUpdateFiles>
      <CodeSignUpdateFiles Condition="'$(CodeSignTest)' != 'true' OR '$(CodeSignTestUpdateFiles)' == 'true'">true</CodeSignUpdateFiles>
    </PropertyGroup>

    <Message Text="@(CodeSignDelete -> 'TEST DELETE %(FullPath)', '%0A')" Condition="'$(CodeSignUpdateFiles)' != 'true'" />
    <Delete Files="@(CodeSignDelete)" Condition="'$(CodeSignUpdateFiles)' == 'true'" />

    <Message Text="TEST EXECUTE %(CodeSignJob.CodeSignCopyScript)" Condition="'$(CodeSignUpdateFiles)' != 'true'" />
    <Exec Command="%(CodeSignJob.CodeSignCopyScript)" Condition="'$(CodeSignUpdateFiles)' == 'true'" />
  </Target>

  <!--
 ==================================================================================================
  CleanCodeSign: Clean task.
 ==================================================================================================-->
  <PropertyGroup>
    <CleanDependsOn>CleanCodeSign;$(CleanDependsOn)</CleanDependsOn>
    <CleanCodeSignDependsOn>CleanCodeSignCore</CleanCodeSignDependsOn>
  </PropertyGroup>
  
  <Target Name="CleanCodeSign" DependsOnTargets="$(CleanCodeSignDependsOn)"/>
  
  <Target Name="CleanCodeSignCore">
    <UpdateCodeSignMetadata CodeSign="@(CodeSign)" ManifestDirectory="$(CodeSignManifestPath)" ManifestExtension="$(CodeSignManifestExtension)">
      <Output TaskParameter="CodeSignUpdated" ItemName="CodeSignWithManifest" />
    </UpdateCodeSignMetadata>
    <Delete Files="@(CodeSignWithManifest -> '%(ManifestPath)')" />
  </Target>

  <!--
 ==================================================================================================
  GetCodeSignFromManifest: Reads CodeSign metadata from manifest files.
 ==================================================================================================-->
  <UsingTask TaskName="GetCodeSignFromManifest" TaskFactory="CodeTaskFactory" AssemblyFile="$(CodeTaskFactoryAssemblyFile)">
    <ParameterGroup>
      <ManifestFiles Required="true" ParameterType="Microsoft.Build.Framework.ITaskItem[]" />
      <OutputRoot Required="true" ParameterType="System.String" />
      <CodeSign Output="true" ParameterType="Microsoft.Build.Framework.ITaskItem[]" />
    </ParameterGroup>
    <Task>
      <Using Namespace="System.Text.RegularExpressions" />
      <Code Type="Fragment" Language="cs">
        <![CDATA[
            string regex = "^[a-zA-Z]+\\s*=\\s*.*";
            char[] trimEntry = new char[] { '\r', ' ' };
            List<ITaskItem> codeSignItems = new List<ITaskItem>();
            
            foreach (ITaskItem manifestItem in ManifestFiles) {
                TaskItem signItem = new TaskItem();
                string manifest = manifestItem.ItemSpec.ToString();
                if (!File.Exists(manifest)) {
                    Log.LogError("Manifest file could not be found: {0}", manifest);
                }

                string[] lines = File.ReadAllText(manifest).Trim().Split('\n');
                var badEntries = from s in lines let t = s.Trim(trimEntry) where !Regex.IsMatch(t, regex) select s;
                if (badEntries.Count<string>() > 0) {
                    Log.LogError("CodeSign metadata error: One or more invalid key/value pair entries found in the manifest {0}", manifest);
                }

                var metaQuery = from s in lines let t = s.Trim(trimEntry) where Regex.IsMatch(t, regex) let kv = t.Split('=')
                                select new KeyValuePair<string, string>(kv[0].Trim(), kv[1].Trim());
                var itemSpec = from e in metaQuery where e.Key == "ItemSpec" select e;
                if (itemSpec.Count<KeyValuePair<string, string>>() == 0) {
                    Log.LogError("CodeSign metadata error: Could not find the 'ItemSpec' key/value pair entry!");
                }
                signItem.ItemSpec = itemSpec.First<KeyValuePair<string, string>>().Value;
                
                string pathHashCode = signItem.GetMetadata("FullPath").GetHashCode().ToString();
                signItem.SetMetadata("PathHashCode", pathHashCode); 
                signItem.SetMetadata("ManifestPath", manifest);
                
                foreach (KeyValuePair<string, string> metaItem in metaQuery) {
                    if (metaItem.Key != "ItemSpec") {
                        if(!string.IsNullOrEmpty(metaItem.Value))
                          signItem.SetMetadata(metaItem.Key, metaItem.Value);
                    }
                }
                
                string relativeOutDir = signItem.GetMetadata("RelativeOutDir");
                if(string.IsNullOrWhiteSpace(relativeOutDir)) {
                  string itemSpecDir = signItem.GetMetadata("RootDir")+signItem.GetMetadata("Directory");
                  if (itemSpecDir.Length > OutputRoot.Length) {
                      string commonRoot = itemSpecDir.Substring(0, OutputRoot.Length);
                      if (commonRoot.ToLowerInvariant() == OutputRoot.ToLowerInvariant()) {
                          relativeOutDir = itemSpecDir.Substring(commonRoot.Length);
                      }
                  }
                }
                if(!string.IsNullOrWhiteSpace(relativeOutDir)) {
                  if(!relativeOutDir.EndsWith("\\")) relativeOutDir += "\\";
                  signItem.SetMetadata("RelativeOutDir", relativeOutDir);
                }
                
                codeSignItems.Add(signItem);
            }
            CodeSign = codeSignItems.ToArray<ITaskItem>();
            ]]>
      </Code>
    </Task>
  </UsingTask>

  <!--
 ==================================================================================================
  UpdateCodeSignMetadata: Adds/Sets the PathHashCode and ManifestPath metadata.
 ==================================================================================================-->
  <UsingTask TaskName="UpdateCodeSignMetadata" TaskFactory="CodeTaskFactory" AssemblyFile="$(CodeTaskFactoryAssemblyFile)">
    <ParameterGroup>
      <CodeSign Required="true" ParameterType="Microsoft.Build.Framework.ITaskItem[]" />
      <ManifestDirectory Required="true" ParameterType="System.String" />
      <ManifestExtension Required="true" ParameterType="System.String" />
      <CodeSignUpdated Output="true" ParameterType="Microsoft.Build.Framework.ITaskItem[]" />
    </ParameterGroup>
    <Task>
      <Code Type="Fragment" Language="cs">
        <![CDATA[
            foreach(var item in CodeSign) { 
                string pathHashCode = item.GetMetadata("FullPath").GetHashCode().ToString();
                string metaFileName = item.GetMetadata("FileName") + item.GetMetadata("Extension") + "." + pathHashCode + ManifestExtension;
                item.SetMetadata("ManifestPath", System.IO.Path.Combine(ManifestDirectory, metaFileName )); 
                item.SetMetadata("PathHashCode", pathHashCode); 
            }
            CodeSignUpdated = CodeSign;
            ]]>
      </Code>
    </Task>
  </UsingTask>

  <!--
 ==================================================================================================
  SortItems: Simple task for sorting item groups by ItemSpec (identity metadata).
 ==================================================================================================-->
  <UsingTask TaskName="SortItems" TaskFactory="CodeTaskFactory" AssemblyFile="$(CodeTaskFactoryAssemblyFile)">
    <ParameterGroup>
      <ItemGroup Required="true" ParameterType="Microsoft.Build.Framework.ITaskItem[]" />
      <SortedItemGroup Output="true" ParameterType="Microsoft.Build.Framework.ITaskItem[]" />
    </ParameterGroup>
    <Task>
      <Code Type="Fragment" Language="cs">
        <![CDATA[
            List<ITaskItem> sortedItems = ItemGroup.ToList<ITaskItem>();
            sortedItems.Sort((a, b) => a.ItemSpec.CompareTo(b.ItemSpec));
            SortedItemGroup = sortedItems.ToArray<ITaskItem>();            
            ]]>
      </Code>
    </Task>
  </UsingTask>

</Project>
